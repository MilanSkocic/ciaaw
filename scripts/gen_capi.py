r"""Generate sources for Fortran."""
from typing import List
import argparse
import tomlkit

newline = "\n"
latest_year = "2021"
celement_len = 25 
csymbol_len = 9
cft_len = 9

def get_year(fpath: str)->str:
    return fpath.split("/")[-1].split("_")[1].split(".")[0]

def get_suffix(year):
    if year == latest_year:
        suffix = ""
    else:
        suffix = "_" + year

    return suffix

def write_module_start(f, year):
    suffix = "_" + year
    f.write("module capi__saw" + suffix + newline)
    f.write("    !! Codata Constants - Autogenerated"+newline)
    f.write("    use iso_c_binding, only: c_null_char, c_int" + newline)
    f.write("    use stdlib_kinds, only: dp, int32"+newline)
    f.write("    use ciaaw__saw" + suffix + newline)
    f.write("    use ciaaw__saw_type" + newline)
    f.write("    private"+newline)
    f.write(newline)

def write_year(f, year):
    suffix = get_suffix(year)
    f.write(f"integer(c_int), protected, public, bind(C, name=\"capi_saw_YEAR{suffix}\") :: capi_YEAR{suffix:s} = YEAR{suffix:s} !capi" + newline)
    f.write(newline)

def f2c(fstring, n)->str:
    cstring = ['\" \"'] * n
    flist = list(map(lambda s: '"' + s + '"', fstring))
    cstring[:len(flist)] = flist[:]
    cstring[len(flist)] = "c_null_char"
    return cstring

def c2code(cstring: List[str])->str:
    indexes = (0, 10, 20)
    code = []
    for i in range(0, len(indexes)-1):
        j = indexes[i]
        k = indexes[i+1]
        code.append(", ".join(cstring[j:k]))
    code.append(", ".join(cstring[indexes[-1]:]))

    return code
    

def write_constant(f, element, symbol, z, saw_min, saw_max, saw, saw_u, asaw, asaw_u, footnotes, year, count):
    suffix = get_suffix(year)
    
    ctag = ""

    var = symbol + suffix

    f.write(f"type(capi_saw_type), protected, public, bind(C, name=\"ciaaw_saw_{var:s}{suffix}\") ::&" + ctag + newline)
    f.write(f"capi_{count:d}{suffix} = capi_saw_type(&" + ctag + newline)

    
    # ELEMENT
    cname = f2c(element, celement_len) # is list of characters.
    f.write("[")
    f.write(",".join(cname))
    f.write("], &" + ctag + newline)
    
    # SYMBOL
    cname = f2c(symbol, csymbol_len) # is list of characters.
    f.write("[")
    f.write(",".join(cname))
    f.write("], &" + ctag + newline)
           
    # Z
    f.write(f"{var:s}%z, &" + ctag + newline)

    # SAW 
    f.write(f"{var:s}%saw_min, &" + ctag + newline)
    f.write(f"{var:s}%saw_max, &" + ctag + newline)
    f.write(f"{var:s}%saw, &" + ctag + newline)
    f.write(f"{var:s}%saw_u, &" + ctag + newline)
    f.write(f"{var:s}%asaw, &" + ctag + newline)
    f.write(f"{var:s}%saw_u, &" + ctag + newline)

    # footnotes
    cname = f2c(footnotes, cft_len) # is list of characters.
    f.write("[")
    f.write(",".join(cname))
    f.write("])" + ctag + newline)
   
    f.write(newline)

def write_module_end(f, year):
    suffix = "_" + year 
    f.write("end module capi__saw" + suffix)


def run(fpath_ast: str, fpath_code: str)->None:
    
    year = get_year(fpath_ast)
    
    fcode = open(fpath_code, "w")
    fast = open(fpath_ast, "r")

    write_module_start(fcode, year)
    write_year(fcode, year)

    ast = tomlkit.load(fast)
    for i, var in enumerate(ast.keys()):
        element = ast[var]["element"]
        symbol = ast[var]["symbol"]
        z = ast[var]["z"]
        saw_min = ast[var]["saw_min"]
        saw_max = ast[var]["saw_max"]
        saw = ast[var]["saw"]
        saw_u = ast[var]["saw_u"]
        asaw = ast[var]["asaw"]
        asaw_u = ast[var]["asaw_u"]
        footnotes = ast[var]["footnotes"]
    
        write_constant(fcode, element, symbol, z, saw_min, saw_max, saw, saw_u, asaw, asaw_u, footnotes, year, i)

    write_module_end(fcode, year)

    fast.close()
    fcode.close()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog='gensrc', description='Generate source code.')
    parser.add_argument("ast", help="File path to the Toml file for ast input.")
    parser.add_argument("code", help="File path to the source file for output.")
    args = parser.parse_args() 

    run(args.ast, args.code)
